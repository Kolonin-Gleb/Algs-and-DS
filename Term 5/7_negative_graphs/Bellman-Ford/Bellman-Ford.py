# Алгоритм Беллмана-Форда = алгоритм поиска кратчайшего пути в взвешенном графе с отрицательными ребрами.
# При наличии в графе отрицательного цикла задача поиска кратчайшего пути теряет смысл, т.к. он уходит в -inf
# Эта реализация алгоритма сообщает о наличии отрицательного цикла, при его присутствии

# Хорошее объяснение на русском: https://youtu.be/950mtbENLVU
# Пример на английском: https://youtu.be/ne9eZ4ezg0Y

# Обозначения:
'''
# s   - исходная вершина
# Wuv - расстояние до вершины u (из s) + расстояние до v (из u)
# Dv  - сумма расстояний пути из s в v
# n - число вершин
'''

# Принцип алгоритма:
'''
# 1 назначить Dv для каждой вершины = +inf, кроме исходной вершины s (для неё путь = 0)
# 2. Обойти n-1 раз каждую вершину (u v) обновляя кратчайший путь до каждой вершины из исходной
Dv = min(Dv, Du + Wuv)
# 3. Проверить на наличие отрицательного цикла.
'''
# Реализация

def bellman_ford(nodes: list, edges: dict, source_index=0):
    # Инициализация словаря хранящего значения наикратчайших путей во все вершины из source_index
    # Используя матрицу смежности
    # path_lengths = {v: float('inf') for v in nodes} # Усложненная версия с генератором словаря

    path_lengths = dict()
    for v in nodes:
        path_lengths[v] = float('inf')

    path_lengths[source_index] = 0

    # Инициализация словаря хранящего списки вершин, 
    # что являются наикартчайшими путями во все вершины из source_index
    # paths = {v: [] for v in nodes} # Усложненная версия с генератором словаря
    paths = dict()
    for v in nodes:
        paths[v] = []

    paths[source_index] = [source_index] # Путь в начальную вершину - он сам

    # Основной цикл - вычисление наименьшего растояния до каждой вершины используя разные пути 
    # Итерация по всем вершинам
    # При первой итерации расстояние до вершины u = 0, т.к. это стартовая вершина
    for _ in range(len(nodes) - 1):
        # Итерация по всем ребрам (Не только смежным с текущей вершиной!)
        for (u, v), w_uv in edges.items(): # Взятие вершин и расстояния между ними из матрицы смежности
            if path_lengths[u] + w_uv < path_lengths[v]: # Расстояние до вершины u + от u до v < известное расстояние до u
                path_lengths[v] = path_lengths[u] + w_uv # Обновление длины кратчайшего пути до v из u
                paths[v] = paths[u] + [v] # Обновление вершин лежащих в кратчайшем пути
    
    # Т.к. используется матрица смежности может быть найден более короткий путь, чем тот, что был опр. ранее

    # Вспомогательный цикл проверки на наличие отрицательного цикла 
    for (u, v), w_uv in edges.items():
        if path_lengths[u] + w_uv < path_lengths[v]: # Если путь из s в u + u в v < пути в v
            print("В графе имеется отрицательный цикл!") # Это наглядно видно, при запуске анимации алгоритма
            break

    return path_lengths, paths


# Входные данные

# 1. Граф без отирицательных ребер
'''
nodes = [0, 1, 2, 3, 4, 5] # Названия вершин
# Матрица смежности
edges = {(0, 1): 1.0, (1, 0): 1.0, (0, 2): 1.5, (2, 0): 1.5,
        (0, 3): 2.0, (3, 0): 2.0, (1, 3): 0.5, (3, 1): 0.5,
        (1, 4): 2.5, (4, 1): 2.5, (2, 3): 1.5, (3, 2): 1.5,
        (4, 5): 2.0, (5, 4): 2.0,
        (5, 3): 1.0}
# Вывод
shortest_path_lengths, shortest_paths = bellman_ford(nodes, edges, 0)
print("Найкратчайшие пути из заданной вершины во все остальные: ")
print(shortest_path_lengths) # Путь в 3 вершину - минимальный = 1.5
print("Вершины, лежащие в кратчайших путях")
print(shortest_paths) # Путь лежит через вершины 0, 1, 3
'''
# 2. Граф с 1 отрицательным ребром
'''
nodes = [0, 1, 2, 3, 4, 5] # Названия вершин
# Матрица смежности
edges = {(0, 1): 1.0, (1, 0): 1.0, (0, 2): 1.5, (2, 0): 1.5,
        (0, 3): 2.0, (3, 0): 2.0, (1, 3): 0.5, (3, 1): 0.5,
        (1, 4): 2.5, (4, 1): 2.5, (2, 3): 1.5, (3, 2): 1.5,
        (4, 5): 2.0, (5, 4): 2.0,
        (5, 3): -4.5}

# Вывод
shortest_path_lengths, shortest_paths = bellman_ford(nodes, edges, 0)
print("Найкратчайшие пути из заданной вершины во все остальные: ")
print(shortest_path_lengths) # Путь в 3 вершину - минимальный = 1.0
print("Вершины, лежащие в кратчайших путях")
print(shortest_paths) # Путь лежит через вершины 0, 1, 4, 5, 3
'''

'''
# 3. Граф с отрицательным циклом
nodes = [0, 1, 2, 3, 4, 5] # Названия вершин
# Матрица смежности
edges = {(0, 1): 1.0, (1, 0): 1.0, (0, 2): 1.5, (2, 0): 1.5,
        (0, 3): 2.0, (3, 0): 2.0, (1, 3): 0.5, (3, 1): 0.5,
        (1, 4): 2.5, (4, 1): 2.5, (2, 3): 1.5, (3, 2): 1.5,
        (4, 5): 2.0, (5, 4): 2.0,
        (5, 3): -5.5}

# Вывод
shortest_path_lengths, shortest_paths = bellman_ford(nodes, edges, 0)
print("Найкратчайшие пути из заданной вершины во все остальные: ")
print(shortest_path_lengths) # Путь в 3 вершину - минимальный = 1.0
print("Вершины, лежащие в кратчайших путях")
print(shortest_paths) # Путь лежит через вершины 0, 1, 4, 5, 3
'''

