# Алгоритм Флойда-Уоршалла = алгоритм поиска кратчайшего пути в взвешенном графе с отрицательными ребрами.
# При наличии в графе отрицательного цикла задача поиска кратчайшего пути теряет смысл, т.к. он уходит в -inf
# Эта реализация алгоритма сообщает о наличии отрицательного цикла, при его присутствии

# Хорошее оъяснение на русском
# https://www.techiedelight.com/ru/pairs-shortest-paths-floyd-warshall-algorithm/


# Обозначения
'''

'''


# Рекурсивная функция для печати пути до заданной вершины `u` из исходной вершины `v`
# Вместо того, чтобы писать эту вспомогательную функцию, можно было сделать цикл внутри функции
# printSolution. Т.к. главная задача - сформировать route
def printPath(path, v, u, route):
    if path[v][u] == v: # Прерывание при нахождении вершины, что исп. в кратчайшем пути
        return None
    printPath(path, v, path[v][u], route)
    route.append(path[v][u])
 
 
# Функция печати вершин в кратчайшем пути и его длины
# Между всеми парами вершин
def printSolution(path, n):
    for v in range(n):
        for u in range(n):
            if u != v and path[v][u] != -1: # Разные вершины, между которыми есть путь
                route = [v]
                printPath(path, v, u, route) # Напечатать путь между ними начиная с route[v]
                route.append(u)
                print(f'The shortest path from {v} —> {u} is', route)


# Функция для запуска алгоритма Флойда-Уоршалла
def floydWarshall(adjMatrix):

    # вершин в графе
    n = len(adjMatrix)

    # Матрица, хранящая значение наикартчайших путей из каждой вершины в каждую
    cost = adjMatrix.copy()

    # Вершины, что содержатся в кратчайших путях
    # Для каждой вершины создаётся список под n вершин
    path = []
    for y in range(n):
        lst = [None for x in range(n)]
        path.append(lst)

    # path = [[None for x in range(n)] for y in range(n)] # На генераторном выражении
    # print(path)

    '''
    adjMatrix = [
    [0, I, -2, I],
    [4, 0, 3, I],
    [I, I, 0, 2],
    [I, -1, I, 0]]
    '''

    # инициализация исходных способов добраться до каждой вершины
    for v in range(n): # По строкам
        for u in range(n): # По столбцам
            if v == u:
                path[v][u] = 0 # Длина пути из вершины в саму себя
            elif cost[v][u] != float('inf'):
                path[v][u] = v # В u можно добраться из v
            else:
                path[v][u] = -1 # Вершины с именем -1 нет, т.е. это обозначение, что добраться нельзя


    # print(*path, sep='\n')
    # Исходные способы добраться до каждой вершины
    #    0    1  2   3
    # 0 [0, -1, 0, -1]
    # 1 [1, 0, 1, -1]
    # 2 [-1, -1, 0, 2]
    # 3 [-1, 3, -1, 0]

    # Непосредственный запуск Флойда-Уоршалла на подготовленных данных
    for k in range(n):
        for v in range(n):
            for u in range(n):
                # Если вершина `k` находится на пути из `v` в `u`,
                # и путь через неё короче
                if cost[v][k] != float('inf') and cost[k][u] != float('inf') and \
                    (cost[v][k] + cost[k][u] < cost[v][u]):
                    # обновить значение cost[v][u] и path[v][u]
                    cost[v][u] = cost[v][k] + cost[k][u]
                    path[v][u] = path[k][u]

            # Если диагональные элементы становятся отрицательными,
            # содержится цикл отрицательного веса
            if cost[v][v] < 0:
                print('В графе имеется отрицательный цикл!')
                return None

    # Временная сложность алгоритма O(V^3), где V - кол. вершин

    # Вывести кратчайший путь между всеми парами вершин
    printSolution(path, n)
    return 1


# определить бесконечность
I = float('inf')

# с учетом представления смежности матрицы
adjMatrix = [
    [0, I, -2, I],
    [4, 0, 3, I],
    [I, I, 0, 2],
    [I, -1, I, 0]
]

# Запуск алгоритма
floydWarshall(adjMatrix)

# Читать матрицу смежности нужно слева на прово-верх
#     0   1   2  3
# 0  [0, I, -2, I],
# 1  [4, 0, 3, I],
# 2  [I, I, 0, 2],
# 3  [I, -1, I, 0]
