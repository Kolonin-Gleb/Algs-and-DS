# Домашняя работа Номер 1

# Я не стал учитывать сложность ввода данных в оценке сложности.

# 1. Напишите программу, которая будет отвечать на вопроc: "Есть ли среди n студентов те, у кого др в один день?".
'''
n = int(input())
birthdays = set()

# > числа дней в обычном году
if n > 365: # O(1) # Если бы не эта проверка, работало бы за  O(n)
    print("Да, есть у кого др в 1 день")
else:
    for d in range(n):
        bd = input()
        if bd in birthdays: # O(1)
            print("Да, есть у кого др в 1 день")
            break
        else:
            birthdays.add(bd) # O(1)
'''

# 2. Оцените ее вычислительную сложность, расписав оценку "О большое" для каждой строчки отдельно.
# Оценка вычислительной сложности в Big-O notation
'''
O(1) + O(1) + O(1) + O(1) = O(1)
'''

# 3. Подумайте, можно ли уменьшить Вашу оценку вычислительной сложности, выбрав другую структуру данных.
'''
Для определения наличия совпадений ДР я использую проверку на присутствие в множестве.
Множество - реализовано через хеш таблицы, поэтому нет способа уменьшить вычислительную сложность
заменив структуру данных
'''


# Домашняя работа Номер 2

# 2. Посчитайте O(n) для [математический пример]
# См. файл Вычисление O для мат. примера

# 3. Приведите примеры алгоритмов с вычислительной сложностью 
'''
О(1) - Меньше или больше число какого-то числа
O(log n) - Бинарный поиск
O(n log n) - сортировка Шелла
O(n) - простой/линейный поиск
O(n^2) - сортировка пузырьком, сортировка вставками, быстрая сортировка (худший случай)
O(2^n) - некий алгоритм, работающий за экспоненциальное время (по мере роста данных сложность очень быстро возрастает)
'''

# 1. Придумайте 10 функций f(n), напишите оценку O(n) для них и 
# расположите их в порядке убывания вычислительной сложности
# (сначала более быстрые, потом менее быстрые)
# При решении опирался на статью: https://habr.com/ru/post/188010/
# Использовал код алгоритмов из 3его семестра

# Самый быстрый
# 1) O(1) - Простое сравнение
'''
if (int(input()) > 10):
    print("Больше 10")
else:
    print("Меньше 10")
'''

# 2) O(log(n)) - Бинарный поиск
'''
# Будет возращать индекс искомого элемента

def binary_search(descending_arr, search_for):
  smallest_element_index = len(nums) - 1
  biggest_element_index = 0
  searched_num_index = None

  while (biggest_element_index <= smallest_element_index) and (searched_num_index == None): #start searching cycle
    mid = (smallest_element_index + biggest_element_index) // 2 #сounting middle

    if nums[mid] == search_for:
      searched_num_index = mid
    else:
      if search_for < nums[mid]: #Search in right part
        biggest_element_index = mid + 1
      else: #Search in left part
        smallest_element_index = mid - 1 

  return searched_num_index


nums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 22]
nums.sort(reverse=True)

print(binary_search(nums, 0))
'''

# 3) O(nlog(n)) - сортировка слиянием
'''
def merge_sort(arr, first, last): # Декомпозирует с.д.
    mid = len(first + last) / 2
    
    merge_sort(arr, first, mid)
    merge_sort(arr, mid+1, last)
    merge(arr, first, mid, last)


def merge(arr, first, mid, last): # Собирает с.д.
    return None # Возращаем новый массив, что мы сформировали

nums = [0, 4, 3, 2, 7, 8, 9, 6, 5, 1]

merge_sort(nums)
print(nums)
'''


# 4) O(n) - Простой поиск сравнением
'''
lst = [0, 1, 2, 3, 4, 5, 7, 9, 8, 6, 0]

for el in lst:
    if el == 3:
        print("значение найдено")
'''

# 5) O(n^2) - Сортировка пузырьком
'''
def foo(arr):
  # range(start, stop, step)
  for i in range(len(arr), 0, -1): # Идём по массиву с последнего элемента
    for j in range(1, i): #Сортируем массив
      if arr[j-1] > arr[j]:
        arr[j-1], arr[j] = arr[j], arr[j-1] #Меняем элементы местами
  return arr

arr = [1, 2, 3, 4, 2, 1, 3, 4, 3, 5, -2, 2, -2, 65, 2, 2] # len = 16
foo(arr)

# Это сортировка пузырьком!
# Вычисление сложности алг. сортировки пузырьком
# Данный алг. меняет элементы местами, поэтому время для его завершения быстро растёт при росте входных данных
# Ответ: O(n^2)
'''
# Самый медленный

